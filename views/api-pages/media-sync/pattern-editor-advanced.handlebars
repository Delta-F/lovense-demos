<div class="api-documentation">
  <h1>Media Sync - Pattern Editor Advanced</h1>
  <div class="content">
    <div class="peditor-advanced">
      <style>
        :root {
          --primary-color: #667eea;
          --primary-dark: #5a6fd8;
          --primary-light: #e8ecff;
          --secondary-color: #764ba2;
          --success-color: #28a745;
          --success-light: #d4edda;
          --warning-color: #ffc107;
          --warning-light: #fff3cd;
          --danger-color: #dc3545;
          --danger-light: #f8d7da;
          --info-color: #17a2b8;
          --info-light: #d1ecf1;
          --light-gray: #f8f9fa;
          --medium-gray: #e9ecef;
          --dark-gray: #6c757d;
          --border-color: #dee2e6;
          --text-primary: #212529;
          --text-secondary: #6c757d;
          --text-muted: #868e96;
        }

        .peditor-advanced fieldset { 
          border: 2px solid var(--border-color); 
          padding: 16px; 
          margin: 16px 0; 
          border-radius: 8px;
          background: white;
          box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .peditor-advanced legend { 
          padding: 0 8px; 
          font-size: 16px; 
          font-weight: 700; 
          color: var(--primary-color);
          background: white;
        }
        .peditor-advanced label { 
          display: inline-block; 
          min-width: 80px; 
          font-size: 14px; 
          font-weight: 600;
          color: var(--text-primary);
        }
        .peditor-advanced input[type="text"],
        .peditor-advanced input[type="number"] { 
          width: 200px; 
          padding: 8px 12px; 
          border: 2px solid var(--border-color);
          border-radius: 6px;
          font-size: 14px;
          transition: all 0.2s ease;
        }
        .peditor-advanced input[type="text"]:focus,
        .peditor-advanced input[type="number"]:focus {
          outline: none;
          border-color: var(--primary-color);
          box-shadow: 0 0 0 3px var(--primary-light);
        }
        .peditor-advanced .row { margin: 8px 0; }
        .peditor-advanced button { 
          padding: 8px 16px; 
          margin-right: 8px; 
          font-size: 14px; 
          font-weight: 500;
          border: 1px solid #dee2e6;
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          background: #f8f9fa;
          color: #495057;
        }
        .peditor-advanced button:hover {
          background: #e9ecef;
          border-color: #adb5bd;
        }
        .peditor-advanced .btn-success {
          background: #28a745;
          color: white;
          border-color: #28a745;
        }
        .peditor-advanced .btn-success:hover {
          background: #218838;
          border-color: #1e7e34;
        }
        .peditor-advanced .btn-danger {
          background: #f8f9fa;
          color: #dc3545;
          border-color: #dc3545;
        }
        .peditor-advanced .btn-danger:hover {
          background: #dc3545;
          color: white;
        }

        .peditor-advanced .grid { 
          display: grid; 
          grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
          gap: 16px; 
          align-items: start; 
        }
        .peditor-advanced #status { 
          padding: 12px 20px; 
          background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%); 
          color: white; 
          border-radius: 8px; 
          font-weight: 700; 
          text-align: center; 
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          margin-bottom: 20px;
          font-size: 16px;
          letter-spacing: 0.5px;
        }

        .peditor-advanced #qr { 
          max-width: 240px; 
          border: 2px solid var(--border-color); 
          border-radius: 8px;
        }
        .peditor-advanced code { 
          background: var(--light-gray); 
          padding: 4px 8px; 
          border-radius: 4px; 
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
          border: 1px solid var(--border-color);
        }
        .peditor-advanced .muted { color: var(--text-muted); }
        .peditor-advanced .toys-table { 
          width: 100%; 
          border-collapse: collapse; 
          border-radius: 8px;
          overflow: hidden;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .peditor-advanced .toys-table th, .peditor-advanced .toys-table td { 
          border: 1px solid var(--border-color); 
          padding: 8px 12px; 
          text-align: left; 
          font-size: 12px;
        }
        .peditor-advanced .toys-table th { 
          background: #f8f9fa;
          color: #495057;
          font-weight: 500;
          border-bottom: 2px solid #dee2e6;
        }
        .peditor-advanced .toys-table tr:nth-child(even) {
          background: var(--light-gray);
        }
        .peditor-advanced textarea { 
          width: 100%; 
          min-height: 120px; 
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; 
          font-size: 12px; 
          padding: 12px;
          border: 2px solid var(--border-color);
          border-radius: 6px;
          transition: all 0.2s ease;
        }
        .peditor-advanced textarea:focus {
          outline: none;
          border-color: var(--primary-color);
          box-shadow: 0 0 0 3px var(--primary-light);
        }
        .peditor-advanced .pattern-entry { 
          border: 2px solid var(--border-color); 
          border-radius: 8px; 
          padding: 16px; 
          margin: 12px 0; 
          background: white; 
          transition: all 0.3s ease;
          box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .peditor-advanced .pattern-entry:hover { 
          box-shadow: 0 8px 24px rgba(0,0,0,0.15); 
          transform: translateY(-2px);
          border-color: var(--primary-color);
        }
        .peditor-advanced .pattern-entry h4 { 
          margin: 0 0 16px 0; 
          color: var(--primary-color); 
          font-size: 16px; 
          font-weight: 700; 
        }
        .peditor-advanced .pattern-entry select, .peditor-advanced .pattern-entry input, .peditor-advanced .pattern-entry textarea { 
          width: 100%; 
          padding: 8px 12px; 
          border: 2px solid var(--border-color); 
          border-radius: 6px; 
          font-size: 14px; 
          transition: all 0.2s ease;
        }
        .peditor-advanced .pattern-entry select:focus, .peditor-advanced .pattern-entry input:focus, .peditor-advanced .pattern-entry textarea:focus { 
          outline: none; 
          border-color: var(--primary-color); 
          box-shadow: 0 0 0 3px var(--primary-light); 
        }
        .peditor-advanced .pattern-entry label { 
          display: block; 
          margin-bottom: 6px; 
          font-weight: 600; 
          color: var(--text-primary); 
          font-size: 14px; 
        }
        .peditor-advanced .pattern-entry .note { 
          font-size: 12px; 
          color: var(--text-muted); 
          margin-top: 6px; 
          font-style: italic;
        }
        .peditor-advanced .api-demo {
          margin-top: 16px;
          border: 2px solid var(--border-color);
          border-radius: 8px;
          background: white;
          box-shadow: 0 2px 8px rgba(0,0,0,0.05);
          overflow: hidden;
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
        }
        .peditor-advanced .api-demo-header {
          background: linear-gradient(135deg, var(--medium-gray), #d6d8db);
          padding: 12px 16px;
          border-bottom: 2px solid var(--border-color);
          font-weight: 700;
          font-size: 14px;
          color: var(--text-primary);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .peditor-advanced .api-demo-content {
          padding: 16px;
        }
        .peditor-advanced .api-section {
          margin-bottom: 16px;
        }
        .peditor-advanced .api-section:last-child {
          margin-bottom: 0;
        }
        .peditor-advanced .api-label {
          font-weight: 700;
          font-size: 14px;
          color: var(--primary-color);
          margin-bottom: 8px;
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .peditor-advanced .api-label::before {
          content: "▶";
          font-size: 12px;
        }
        .peditor-advanced .api-code {
          background: var(--light-gray);
          border: 2px solid var(--border-color);
          border-radius: 6px;
          padding: 12px 16px;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
          font-size: 12px;
          line-height: 1.5;
          color: var(--text-primary);
          white-space: pre-wrap;
          word-wrap: break-word;
          word-break: break-all;
          overflow-wrap: break-word;
          position: relative;
          overflow-x: auto;
          overflow-y: auto;
          max-width: 100%;
          width: 100%;
          max-height: 300px;
          box-sizing: border-box;
        }

        .peditor-advanced .status-indicator {
          padding: 6px 12px;
          border-radius: 20px;
          font-size: 12px;
          font-weight: 600;
          text-align: center;
          min-width: 100px;
        }
        .peditor-advanced .status-connected {
          background: var(--success-light);
          color: var(--success-color);
          border: 2px solid var(--success-color);
        }
        .peditor-advanced .status-disconnected {
          background: var(--warning-light);
          color: #856404;
          border: 2px solid var(--warning-color);
        }
        .peditor-advanced .quick-pattern-btn {
          border: 1px solid #ccc;
          background: #f8f9fa;
          color: #495057;
          padding: 4px 8px;
          font-size: 12px;
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        .peditor-advanced .quick-pattern-btn:hover {
          background: #e9ecef;
          border-color: #adb5bd;
        }

        .peditor-advanced .flex-row {
          display: flex;
          align-items: center;
          gap: 12px;
          flex-wrap: wrap;
        }
        .peditor-advanced .flex-row-8 {
          display: flex;
          align-items: center;
          gap: 8px;
          flex-wrap: wrap;
        }
        .peditor-advanced .small-label {
          min-width: auto;
          font-size: 13px;
        }
        .peditor-advanced .auto-label {
          min-width: auto;
        }
        .peditor-advanced .timestamp {
          color: #6f42c1;
          font-weight: 600;
        }
      </style>

      <div id="status">Ready to generate ctoken</div>

      <fieldset>
        <legend>Step 1: Generate ctoken</legend>
        <div class="grid">
          <div>
            <div class="row">
              <label for="userId">userId:</label>
              <input id="userId" type="text" placeholder="deltatest_123456" value="deltatest_123456" />
              <label for="devToken">devToken:</label>
              <input id="devToken" type="text" placeholder="tf7_SsG7X8qJm5l4gSYzfdLSeaZtlLl8ZaWNOSLt_ScnbUpimwPUIxB5l9TAgNle" value="tf7_SsG7X8qJm5l4gSYzfdLSeaZtlLl8ZaWNOSLt_ScnbUpimwPUIxB5l9TAgNle" />
              <button id="btn-generate-ctoken" class="btn-success">Generate ctoken</button>
            </div>
          </div>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="ctoken-request">Click "Generate ctoken" to see the actual request</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="ctoken-response">Response will appear here after request</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Step 2: Create JavaScript Object</legend>
        
        <div class="row">
          <button id="btn-create-object" class="btn-success">Create lovensePattern Object</button>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="create-object-code"><code>&lt;script src=&quot;https://cdn.lovense-api.com/peditor-v2/pattern-sdk.js&quot;&gt;&lt;/script&gt;<br>const lovensePattern = new LovensePattern()</code></div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="create-object-response">Click "Create lovensePattern Object" to see if initialization was successful</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Step 3: Media Initialization</legend>
        
        <!-- Audio Player -->
        <div class="row flex-row">
          <div style="flex: 1; min-width: 300px;">
            <strong>Test Audio:</strong>
            <audio id="test-audio" controls preload="metadata" style="width: 100%; margin: 8px 0;">
              <source src="https://assets.shibbydex.com/audio/d4e5bb34-3673-40c4-ad5a-17e4da998d5a.mp3" type="audio/mpeg" />
              Your browser does not support the audio tag.
            </audio>
          </div>
        </div>
        
        <!-- Configuration and Button in Same Row -->
        <div class="row flex-row">
          <div class="flex-row-8">
            <label for="ctoken-step2" class="auto-label">ctoken:</label>
            <input id="ctoken-step2" type="text" placeholder="[ctoken]" style="width: 200px;" />
          </div>
          <div class="flex-row-8">
            <label for="mediaId" class="auto-label">mediaId:</label>
            <input id="mediaId" type="text" placeholder="[mediaId]" value="test-audio" style="width: 120px;" />
          </div>
          <div class="flex-row-8">
            <label for="duration" class="auto-label">duration:</label>
            <input id="duration" type="number" step="0.001" placeholder="Auto-detect" style="width: 140px;" />
          </div>
          <button id="btn-init" class="btn-success">Init Media</button>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="init-code">Click "Init Media" to see the actual initialization parameters</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Step 4: Connect Remote App</legend>
        <div class="row">
          <button id="btn-get-app" class="btn-success">Get Connection Info (QR / App Link / Unique Code)</button>
        </div>
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px;">
          <!-- QR Code Container -->
          <div id="connectionQr" style="display:none">
            <h3 style="margin: 0 0 12px 0; color: var(--primary-color); font-size: 16px;">Desktop Users (Scan QR Code)</h3>
            <img id="qrImage" alt="QR Code" style="max-width: 180px; border: 2px solid var(--border-color); border-radius: 8px;" />
          </div>
          
          <!-- App Link Container -->
          <div id="connectionLink" style="display:none">
            <h3 style="margin: 0 0 12px 0; color: var(--primary-color); font-size: 16px;">Mobile Users (Open App)</h3>
            <a id="openLink" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: var(--primary-color); color: white; text-decoration: none; border-radius: 6px; word-break: break-all;">Open Lovense Remote</a>
          </div>
          
          <!-- Unique Code Container -->
          <div id="connectionCode" style="display:none; max-width: 200px;">
            <h3 style="margin: 0 0 8px 0; color: var(--primary-color); font-size: 14px;">VR Users (Enter Unique Code)</h3>
            <div style="padding: 8px; background: var(--primary-light); border: 1px solid var(--primary-color); border-radius: 6px; text-align: center;">
              <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Unique Code:</div>
              <span id="textCode" style="font-family: monospace; font-size: 16px; font-weight: 700; color: var(--primary-color); letter-spacing: 1px;"></span>
            </div>
          </div>
          
          <!-- Default Placeholder -->
          <div id="connection-placeholder" style="grid-column: 1 / -1; padding: 20px; text-align: center; color: var(--text-muted); border: 2px dashed var(--border-color); border-radius: 8px;">
            Connection info will appear here after clicking "Get Connection Info"
          </div>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code">lovensePattern.getApp(function (data) {...})</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="getapp-response">Click "Get Connection Info" to see the actual response data</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Step 5: Monitor App Connection Status & Control</legend>
        <div class="row muted">Real-time monitoring of Lovense Remote or VibeMate connection status and session control.</div>
        
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin: 16px 0;">
          <div style="padding: 16px; border-radius: 8px; background: var(--light-gray); border: 2px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
            <div style="font-weight: 700; margin-bottom: 8px; font-size: 14px; color: var(--text-primary);">Connection Status:</div>
            <div id="connection-status" class="status-indicator status-disconnected">Not Connected</div>
          </div>
          
          <div style="padding: 16px; border-radius: 8px; background: var(--light-gray); border: 2px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
            <div style="font-weight: 700; margin-bottom: 8px; font-size: 14px; color: var(--text-primary);">Connected Toys:</div>
            <div id="connected-toys-count" style="padding: 6px 12px; border-radius: 20px; background: var(--dark-gray); color: white; font-weight: 600; font-size: 12px; text-align: center;">0 toys</div>
          </div>
          
          <div style="padding: 16px; border-radius: 8px; background: var(--light-gray); border: 2px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
            <div style="font-weight: 700; margin-bottom: 8px; font-size: 14px; color: var(--text-primary);">Last Event:</div>
            <div id="last-event" style="padding: 6px 12px; border-radius: 4px; background: var(--medium-gray); color: var(--text-secondary); font-size: 12px; font-family: monospace;">Page loaded</div>
          </div>
          
          <div style="padding: 16px; border-radius: 8px; background: var(--light-gray); border: 2px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <button id="btn-exit" class="btn-danger" style="margin: 0;">🚪 Exit Session</button>
            <span class="muted" style="font-size: 11px; margin-top: 4px; text-align: center;">Clean exit</span>
          </div>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code">lovensePattern.exit()</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="exit-response">Click "Exit Session" to see the actual response</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Toy Information</legend>
        <div id="toys-empty" class="row muted">No devices</div>
        <table id="toys-table" class="toys-table" style="display:none">
          <thead>
            <tr>
              <th>Nickname</th>
              <th>Type</th>
              <th>Version</th>
              <th>Battery</th>
              <th>Connection</th>
              <th>ID</th>
            </tr>
          </thead>
          <tbody id="toys-tbody"></tbody>
        </table>
      </fieldset>

      <fieldset>
        <legend>Single Pattern Sync Module</legend>        
        
        <div class="row" style="display: flex; justify-content: space-between; align-items: center;">
          <div class="flex-row-8">
            <button id="btn-load-pattern" class="btn-success">Load Pattern</button>
            <button class="quick-pattern-btn" data-duration="20">20s</button>
            <button class="quick-pattern-btn" data-duration="60">1m</button>
            <button class="quick-pattern-btn" data-duration="300">5m</button>
            <button class="quick-pattern-btn" data-duration="900">15m</button>
            <button class="quick-pattern-btn" data-duration="1800">30m</button>
          </div>
        </div>
        
        <div class="row" style="display: flex; gap: 20px; align-items: flex-start; margin-top: 16px;">
          <div style="flex: 0 0 calc(30% - 10px); min-width: 200px;">
            <label for="pattern-link" style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary);">Pattern Link (optional):</label>
            <input id="pattern-link" type="text" placeholder="https://example.com/pattern.funscript" style="width: 100%; padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;" />
          </div>
          <div style="flex: 0 0 calc(70% - 10px); min-width: 300px;">
            <label for="pattern-data" style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary);">Pattern Data (FunScript JSON):</label>
            <textarea id="pattern-data" placeholder='[{"at":1000, "pos":20}, {"at":3000, "pos":35}]' style="width: 100%; height: 100px; padding: 12px; border: 2px solid var(--border-color); border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; line-height: 1.4; box-sizing: border-box; resize: vertical;">[
  { "at": 1000, "pos": 20 },
  { "at": 3000, "pos": 35 },
  { "at": 6000, "pos": 25 },
  { "at": 9000, "pos": 40 },
  { "at": 12000, "pos": 30 },
  { "at": 15000, "pos": 50 }
]</textarea>
          </div>
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="pattern-call">Click "Load Pattern" to see the actual call with your data</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="pattern-response">Response will appear here after loading</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Advanced: Multiple Patterns for Multiple Toys</legend>
        
        <div class="row" style="display: flex; justify-content: space-between; align-items: center;">
          <div class="flex-row-8">
            <button id="btn-load-multiple-patterns" class="btn-success">Load Multiple Patterns</button>
          </div>
          <div class="flex-row-8">
            <button id="btn-add-pattern" class="btn-success">+ Add Toy Pattern</button>
            <button id="btn-clear-patterns" class="btn-danger">Clear All</button>
          </div>
        </div>
        
        <div id="multiple-patterns-container">
          <!-- Dynamic pattern entries will be added here -->
        </div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="multiple-patterns-call">Click "Load Multiple Patterns" to see the actual call with your configured patterns</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="multiple-patterns-response">Response will appear here after loading</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Pattern Data Management</legend>        
        <div class="row muted">Get patterns by audio/video. If you only support one pattern per video, then there's no need to call it.</div>
        
        <!-- Configuration and Button -->
        <div class="row flex-row">
          <div class="flex-row-8">
            <label for="pattern-page" class="auto-label">Page:</label>
            <input id="pattern-page" type="number" value="1" min="1" style="width: 80px;" />
          </div>
          <div class="flex-row-8">
            <label for="pattern-page-size" class="auto-label">Page Size:</label>
            <input id="pattern-page-size" type="number" value="10" min="1" max="50" style="width: 80px;" />
          </div>
          <button id="btn-get-pattern-list" class="btn-success">Get Pattern List</button>
        </div>
        
        <!-- Pattern List Display -->
        <div id="pattern-list-container" style="margin-top: 16px; display: none;">
          <h4 style="margin: 0 0 12px 0; color: var(--primary-color); font-size: 16px;">Pattern List Results</h4>
          <div id="pattern-list-results" style="max-height: 300px; overflow-y: auto; background: var(--light-gray); border: 2px solid var(--border-color); border-radius: 6px; padding: 12px;">
            <!-- Pattern results will be displayed here -->
          </div>
        </div>

        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Request</div>
              <div class="api-code" id="pattern-list-call">Click "Get Pattern List" to see the actual call with your parameters</div>
            </div>
            <div class="api-section">
              <div class="api-label">Response</div>
              <div class="api-code" id="pattern-list-response">Response will appear here after fetching</div>
            </div>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Pattern Sync Error Monitoring</legend>
        <div class="row muted">Lovense Remote downloads patterns through HTTP requests. This event will be triggered when Lovense Remote or VibeMate fails to download a pattern.</div>
        
        <div class="api-demo">
          <div class="api-demo-content">
            <div class="api-section">
              <div class="api-label">Event</div>
              <div class="api-code">lovensePattern.on("PatternSyncError", (data) => {
  console.log("PatternSyncError", data.msg);
  });</div>
            </div>
            <div class="api-section">
              <div class="api-label">Error Log</div>
              <div class="api-code" id="pattern-sync-errors">No pattern sync errors detected yet.</div>
            </div>
          </div>
        </div>
      </fieldset>



      <!-- 1) Initialization: Lovense SDK -->
      <script src="https://cdn.lovense-api.com/peditor-v2/pattern-sdk.js"></script>
      <script>
        (function () {
          // Global variable to store lovensePattern instance
          let lovensePattern = null;
          
          const statusEl = document.getElementById('status');
          const audioEl = document.getElementById('test-audio');
          const inputUserId = document.getElementById('userId');
          const inputDevToken = document.getElementById('devToken');
          const inputCtokenStep2 = document.getElementById('ctoken-step2');
          const inputMediaId = document.getElementById('mediaId');
          const inputDuration = document.getElementById('duration');
          const btnGenerateCtoken = document.getElementById('btn-generate-ctoken');
          const btnCreateObject = document.getElementById('btn-create-object');
          const btnInit = document.getElementById('btn-init');
          const btnGetApp = document.getElementById('btn-get-app');
          const toysEmptyEl = document.getElementById('toys-empty');
          const toysTableEl = document.getElementById('toys-table');
          const toysTbodyEl = document.getElementById('toys-tbody');
          const inputPatternLink = document.getElementById('pattern-link');
          const inputPatternData = document.getElementById('pattern-data');
          const btnLoadPattern = document.getElementById('btn-load-pattern');
          const btnAddPattern = document.getElementById('btn-add-pattern');
          const btnClearPatterns = document.getElementById('btn-clear-patterns');
          const btnLoadMultiplePatterns = document.getElementById('btn-load-multiple-patterns');
          const multiplePatternsContainer = document.getElementById('multiple-patterns-container');

          const connectionStatusEl = document.getElementById('connection-status');
          const connectedToysCountEl = document.getElementById('connected-toys-count');
          const lastEventEl = document.getElementById('last-event');
          const patternPageEl = document.getElementById('pattern-page');
          const patternPageSizeEl = document.getElementById('pattern-page-size');
          const btnGetPatternList = document.getElementById('btn-get-pattern-list');
          const btnExit = document.getElementById('btn-exit');



          function updateConnectionStatus(status, event) {
            if (connectionStatusEl) {
              if (status === 'connected') {
                connectionStatusEl.textContent = 'Connected';
                connectionStatusEl.className = 'status-indicator status-connected';
              } else {
                connectionStatusEl.textContent = 'Not Connected';
                connectionStatusEl.className = 'status-indicator status-disconnected';
              }
            }
            if (lastEventEl && event) {
              lastEventEl.textContent = event;
            }
          }

          function updateConnectedToysCount(count) {
            if (connectedToysCountEl) {
              connectedToysCountEl.textContent = `${count} toys`;
              if (count > 0) {
                connectedToysCountEl.style.background = 'var(--success-color)';
                connectedToysCountEl.style.color = 'white';
              } else {
                connectedToysCountEl.style.background = 'var(--dark-gray)';
                connectedToysCountEl.style.color = 'white';
              }
            }
          }

          // Helper function to format local machine datetime
          function formatLocalDateTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(now.getMilliseconds()).padStart(3, '0');
            
            return `🕐 ${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
          }

          function getPatternList() {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-list-response').textContent = `${errorTimestamp}\n❌ Error: Please complete initialization first`;
              setStatus('Please complete initialization first');
              return;
            }

            const mediaId = (inputMediaId.value || '').trim();
            if (!mediaId) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-list-response').textContent = `${errorTimestamp}\n❌ Error: MediaId is required`;
              setStatus('MediaId is required for getting pattern list');
              return;
            }

            const page = parseInt(patternPageEl.value) || 1;
            const pageSize = parseInt(patternPageSizeEl.value) || 10;

            const params = {
              mediaId: mediaId,
              page: page,
              pageSize: pageSize
            };

            setStatus('Getting pattern list...');
            const patternListTimestamp = formatLocalDateTime();
            
            // Show the actual call being made
            document.getElementById('pattern-list-call').textContent = `${patternListTimestamp}
lovensePattern.getPatternList({
  mediaId: "${mediaId}",
  page: ${page},
  pageSize: ${pageSize}
}).then((data) => {
  console.log('Pattern list:', data);
  // Process pattern data
  data.forEach((pattern, index) => {
    console.log(\`Pattern \${index + 1}:\`, pattern);
  });
}).catch((error) => {
  console.error('Failed to get patterns:', error);
});`;
            
            console.log('🔺 SDK Call: lovensePattern.getPatternList()', { method: 'getPatternList', parameters: params });

            try {
              // Use Promise-based approach as per API documentation
              lovensePattern.getPatternList(params)
                .then((data) => {
                  const responseTimestamp = formatLocalDateTime();
                  
                  document.getElementById('pattern-list-response').textContent = `${responseTimestamp}
${JSON.stringify(data, null, 2)}`;
                  
                  // Display pattern results in the container
                  displayPatternListResults(data);
                  
                                console.log('✅ SDK Response: getPatternList() successful', {
                response: data,
                patternCount: Array.isArray(data) ? data.length : 'Unknown',
                page: page,
                pageSize: pageSize
              });
                  
                  setStatus(`Pattern list loaded successfully (${Array.isArray(data) ? data.length : 0} patterns found)`);
                })
                .catch((error) => {
                  const errorTimestamp = formatLocalDateTime();
                  document.getElementById('pattern-list-response').textContent = `${errorTimestamp}
Error: ${String((error && error.message) || error)}`;
                  
                  console.log('💥 SDK Error: getPatternList() call error', {
                    error: String((error && error.message) || error),
                    parameters: params,
                    stack: error && error.stack
                  });
                  setStatus('Error calling getPatternList');
                });
            } catch (err) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-list-response').textContent = `${errorTimestamp}
Error: ${String((err && err.message) || err)}`;
              
              console.log('💥 SDK Error: getPatternList() call error', {
                error: String((err && err.message) || err),
                parameters: params,
                stack: err && err.stack
              });
              setStatus('Error calling getPatternList');
            }
          }

          function displayPatternListResults(patterns) {
            const container = document.getElementById('pattern-list-container');
            const resultsDiv = document.getElementById('pattern-list-results');
            
            if (!Array.isArray(patterns) || patterns.length === 0) {
              resultsDiv.innerHTML = '<div class="muted">No patterns found for this media.</div>';
              container.style.display = 'block';
              return;
            }
            
            let html = '';
            patterns.forEach((pattern, index) => {
              const patternId = pattern.id || pattern.patternId || `pattern-${index + 1}`;
              const patternName = pattern.name || pattern.patternName || `Pattern ${index + 1}`;
              const patternType = pattern.type || pattern.patternType || 'Unknown';
              const duration = pattern.duration || pattern.durationMs || 'Unknown';
              const createdAt = pattern.createdAt || pattern.created || 'Unknown';
              
              html += `
                <div style="padding: 8px; margin-bottom: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px;">
                  <div style="font-weight: 600; color: var(--primary-color); margin-bottom: 4px;">${escapeHtml(patternName)}</div>
                  <div style="font-size: 12px; color: var(--text-secondary);">
                    <span>ID: ${escapeHtml(String(patternId))}</span> | 
                    <span>Type: ${escapeHtml(String(patternType))}</span> | 
                    <span>Duration: ${escapeHtml(String(duration))}</span> | 
                    <span>Created: ${escapeHtml(String(createdAt))}</span>
                  </div>
                </div>
              `;
            });
            
            resultsDiv.innerHTML = html;
            container.style.display = 'block';
          }



          function exitLovensePattern() {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('exit-response').textContent = `${errorTimestamp}\n❌ Error: No active Lovense Pattern session to exit`;
              setStatus('No active session to exit');
              return;
            }

            setStatus('Exiting Lovense Pattern session...');
            const exitTimestamp = formatLocalDateTime();
            
            console.log('🔺 SDK Call: lovensePattern.exit()', {
              method: 'exit',
              timestamp: exitTimestamp
            });

            try {
              const responseTimestamp = formatLocalDateTime();
              const result = lovensePattern.exit();
              
              document.getElementById('exit-response').textContent = `${responseTimestamp}
${JSON.stringify(result, null, 2)}`;
              
              console.log('✅ SDK Response: lovensePattern.exit() successful', {
                response: result,
                timestamp: responseTimestamp
              });
              
              // Reset UI state
              updateConnectionStatus('disconnected', 'Session exited');
              updateConnectedToysCount(0);
              renderToys([]);
              
              setStatus('Session exited successfully');
              lovensePattern = null; // Clear the instance
            } catch (err) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('exit-response').textContent = `${errorTimestamp}
Error: ${String((err && err.message) || err)}`;
              
              console.log('💥 SDK Error: lovensePattern.exit() call error', {
                error: String((err && err.message) || err),
                stack: err && err.stack,
                timestamp: errorTimestamp
              });
              setStatus('Error exiting session');
            }
          }



          function setStatus(text) {
            statusEl.textContent = text;
          }



          function generateRandomUserId() {
            const randomNumbers = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
            const randomUserId = `deltatest_${randomNumbers}`;
            
            inputUserId.value = randomUserId;
            return randomUserId;
          }

          function generateRandomMediaId() {
            const randomNumbers = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
            const randomMediaId = `audioid_${randomNumbers}`;
            
            inputMediaId.value = randomMediaId;
            return randomMediaId;
          }

          function generateCtoken() {
            // Auto-generate random userId and mediaId first
            const userId = generateRandomUserId();
            const mediaId = generateRandomMediaId();

            setStatus('Generating ctoken...');
            const timestamp = formatLocalDateTime();
            
            // Show the actual request being made
            const devToken = (inputDevToken.value || '').trim();
            const url = `https://api.lovense-api.com/api/media/pattern/user/ctoken?userId=${encodeURIComponent(userId)}&developerToken=${encodeURIComponent(devToken)}`;
            document.getElementById('ctoken-request').textContent = `${timestamp}
URL: ${url}

{"action": "get ctoken", "userId": "${userId}"}`;

            console.log('🔺 API Request: Generating ctoken', { 
              endpoint: 'https://api.lovense-api.com/api/media/pattern/user/ctoken',
              userId: userId,
              developerToken: devToken
            });

            fetch(url)
              .then(response => response.json())
              .then(data => {
                const responseTimestamp = formatLocalDateTime();
                
                // Show the actual response
                document.getElementById('ctoken-response').textContent = `${responseTimestamp}
${JSON.stringify(data, null, 2)}`;
                
                if (data.result && data.data && data.data.ctoken) {
                  // Auto-fill the ctoken in step 2
                  inputCtokenStep2.value = data.data.ctoken;
                  
                  console.log('✅ API Response: ctoken generated successfully', { 
                    ctoken: data.data.ctoken,
                    userId: userId,
                    fullResponse: data
                  });
                  setStatus('ctoken generated successfully');
                } else {
                  console.log('❌ API Response: Failed to generate ctoken', { 
                    response: data,
                    userId: userId
                  });
                  setStatus('Failed to generate ctoken');
                }
              })
              .catch(error => {
                const errorTimestamp = formatLocalDateTime();
                document.getElementById('ctoken-response').textContent = `${errorTimestamp}
Error: ${String(error)}`;
                
                console.log('💥 API Error: Error generating ctoken', { 
                  error: String(error),
                  userId: userId
                });
                setStatus('Error generating ctoken');
              });
          }

          function ensureSDK() {
            if (typeof LovensePattern === 'undefined') {

              setStatus('SDK not loaded, please check network or CDN');
              return false;
            }
            return true;
          }

          function getDesiredDurationSeconds() {
            const manual = parseFloat(inputDuration.value);
            if (!Number.isNaN(manual) && manual > 0) {
              // If user inputs a value, assume it's in seconds and convert to milliseconds
              const durationMs = manual * 1000;

              return durationMs;
            }
            
            if (Number.isFinite(audioEl.duration) && audioEl.duration > 0) {
              // Audio duration is in seconds, convert to milliseconds
              const durationMs = audioEl.duration * 1000;

              return durationMs;
            }
            
            return undefined;
          }

          function escapeHtml(value) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
            return String(value).replace(/[&<>"']/g, ch => map[ch]);
          }



          function normalizeToy(raw) {
            if (!raw) return null;
            const nickName = raw.nickName || raw.nickname || raw.name || '';
            const toyType = raw.toyType || raw.name || '';
            const toyVersion = raw.toyVersion || raw.version || '';
            const battery = typeof raw.battery === 'number' ? raw.battery : '';
            const connect = typeof raw.connect === 'boolean' ? raw.connect : (raw.status === '1' || raw.status === 1);
            const toyId = raw.toyId || raw.id || raw.deviceId || '';
            return { nickName, toyType, toyVersion, battery, connect, toyId };
          }

          function renderToys(data) {
            let list = Array.isArray(data) ? data : (data && Array.isArray(data.toys) ? data.toys : []);
            list = list.map(normalizeToy).filter(Boolean);
            
            // Always show table with header
            toysTableEl.style.display = 'table';
            
            if (!list.length) {
              toysEmptyEl.style.display = 'block';
              toysTbodyEl.innerHTML = '';
            } else {
            toysEmptyEl.style.display = 'none';
            toysTbodyEl.innerHTML = list.map(t => {
              const batteryStr = t.battery === '' ? '' : `${t.battery}%`;
              return `<tr>
                <td>${escapeHtml(t.nickName)}</td>
                <td>${escapeHtml(t.toyType)}</td>
                <td>${escapeHtml(String(t.toyVersion))}</td>
                <td>${escapeHtml(batteryStr)}</td>
                <td>${t.connect ? 'Connected' : 'Disconnected'}</td>
                <td><code>${escapeHtml(String(t.toyId))}</code></td>
              </tr>`;
            }).join('');
            }
            
            // Update connected toys count
            const connectedCount = list.filter(t => t.connect).length;
            updateConnectedToysCount(connectedCount);
            
            // Update multiple patterns toy dropdowns when toy status changes
            updateToyDropdowns();
            
            // Auto-select first toy for empty pattern cards
            setTimeout(() => {
              const emptyDropdowns = document.querySelectorAll('[id$="-toyId"]');
              const connectedToys = getConnectedToys();
              emptyDropdowns.forEach(dropdown => {
                if (!dropdown.value && connectedToys.length > 0) {
                  dropdown.value = connectedToys[0].toyId;
                }
              });
            }, 100);
          }

          function tryParsePatternData(raw) {
            const trimmed = (raw || '').trim();
            if (!trimmed) return null;
            try {
              const parsed = JSON.parse(trimmed);
              if (!Array.isArray(parsed)) throw new Error('Data must be an array');
              return parsed;
            } catch (e) {

              setStatus('Data parsing failed, please check JSON format');
              return undefined; // indicates parsing was attempted but failed
            }
          }

          function loadPatternFromUI() {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-response').textContent = `${errorTimestamp}\n❌ Error: Please complete initialization first`;
              setStatus('Please complete initialization first');
              return;
            }

            const link = (inputPatternLink.value || '').trim();
            const parsed = tryParsePatternData(inputPatternData.value);
            if (parsed === undefined) return; // JSON format error

            const payload = {
              type: 'funScript',
              patternLink: link || null,
              data: parsed !== null ? parsed : null
            };

            if (payload.data === null && !payload.patternLink) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-response').textContent = `${errorTimestamp}\n❌ Error: loadPattern parameters empty`;
              setStatus('Please fill in Data or Pattern Link');
              return;
            }

            setStatus('Loading Pattern...');
            const patternTimestamp = formatLocalDateTime();
            
            // Show actual call with compact data format
            let displayPayload = {
              type: payload.type
            };
            
            if (payload.data) {
              // Use compact format for display
              displayPayload.data = `[${payload.data.length} points] ${JSON.stringify(payload.data)}`;
            }
            
            if (payload.patternLink) {
              displayPayload.patternLink = payload.patternLink;
            }
            
            document.getElementById('pattern-call').textContent = `${patternTimestamp}
lovensePattern.loadPattern(${JSON.stringify(displayPayload)});`;
            
            console.log('🔺 SDK Call: loadPattern() - Loading single pattern', { 
              payload: payload,
              hasData: payload.data !== null,
              hasLink: payload.patternLink !== null
            });
            
            try {
              const responseTimestamp = formatLocalDateTime();
              const result = lovensePattern.loadPattern(payload);
              
              // Enhanced response display
              const responseInfo = {
                success: true,
                timestamp: responseTimestamp,
                patternType: payload.type,
                hasData: !!payload.data,
                hasLink: !!payload.patternLink,
                dataPoints: payload.data ? payload.data.length : 0,
                sdkResponse: result
              };
              
              document.getElementById('pattern-response').textContent = `${responseTimestamp}
${JSON.stringify(result, null, 2)}`;
              
              console.log('✅ SDK Response: loadPattern() successful', {
                result: result,
                detailedInfo: responseInfo
              });
              setStatus('Pattern loaded successfully');
            } catch (err) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('pattern-response').textContent = `${errorTimestamp}
Error: ${String((err && err.message) || err)}`;
              
              console.log('💥 SDK Error: loadPattern() call error', { 
                error: String((err && err.message) || err),
                payload: payload,
                stack: err && err.stack
              });
              setStatus('Pattern loading error');
            }
          }

          function createLovensePatternObject() {
            if (!ensureSDK()) return;

            try {
              lovensePattern = new LovensePattern();
              
              // Update the object creation display
              const createTimestamp = formatLocalDateTime();
              document.getElementById('create-object-code').innerHTML = `<div class="timestamp">${createTimestamp}</div><code>&lt;script src=&quot;https://cdn.lovense-api.com/peditor-v2/pattern-sdk.js&quot;&gt;&lt;/script&gt;<br>const lovensePattern = new LovensePattern()</code>`;

              // Update the response display
              const responseTimestamp = formatLocalDateTime();
              document.getElementById('create-object-response').textContent = `${responseTimestamp}
✅ Success: LovensePattern object initialized successfully
Ready for media initialization`;


              
              setStatus('LovensePattern object created successfully, ready for initialization');
            } catch (err) {
              console.error(err);
              
              // Update the response display with error
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('create-object-response').textContent = `${errorTimestamp}
❌ Error: ${String((err && err.message) || err)}
Failed to initialize LovensePattern object`;
              
              console.log('💥 SDK Error: Object creation error', { 
                error: String((err && err.message) || err),
                stack: err && err.stack
              });
              setStatus('Object creation error, please check console');
            }
          }

          function initLovensePatternWhenReady() {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('init-code').textContent = `${errorTimestamp}\n❌ Error: Please create LovensePattern object first`;
              setStatus('Please create LovensePattern object first');
              return;
            }

            const ctoken = (inputCtokenStep2.value || '').trim();
            const mediaId = (inputMediaId.value || '').trim();
            const desiredDuration = getDesiredDurationSeconds();

            if (!ctoken || !mediaId) {

              setStatus('Initialization failed: Please generate ctoken and fill in mediaId');
              return;
            }

            if (desiredDuration === undefined) {

              setStatus('Waiting for audio metadata to load...');
              const onMeta = () => {
                audioEl.removeEventListener('loadedmetadata', onMeta);
                setTimeout(() => initLovensePatternWhenReady(), 100); // Small delay to ensure audio is ready
              };
              audioEl.addEventListener('loadedmetadata', onMeta, { once: true });
              if (!audioEl.currentSrc) {
                audioEl.load();
              }
              return;
            }

            try {
              const audioElement = document.querySelector("audio");
              const initParams = {
                ctoken: ctoken,
                mediaId: mediaId,
                videoEl: audioElement,
                duration: desiredDuration
              };
              

              

              
              lovensePattern.init(initParams);
              
              // Update the initialization display
              const initTimestamp = formatLocalDateTime();
              document.getElementById('init-code').textContent = `${initTimestamp}
lovensePattern.init(${JSON.stringify(initParams, null, 2)});`;

              console.log('✅ SDK Initialization: lovensePattern.init completed', { 
                initParams: initParams,
                durationInMs: desiredDuration,
                durationInSeconds: desiredDuration / 1000
              });
              setStatus('Initialized, waiting for App connection or getApp');

              lovensePattern.on('appConnected', () => {
                console.log('🔗 Event: appConnected');
                setStatus('App connected, toys can be controlled');
                updateConnectionStatus('connected', 'App connected');
              });
              lovensePattern.on('appDisconnected', () => {
                console.log('🔌 Event: appDisconnected');
                setStatus('App disconnected, please reconnect Lovense Remote or VibeMate');
                updateConnectionStatus('disconnected', 'App disconnected');
                updateConnectedToysCount(0);
                // Clear toys table when disconnected
                renderToys([]);
              });
              lovensePattern.on('appToyStatus', (data) => {
                console.log('appToyStatus', data);
                
                // Check if there are new toys or status changes
                const currentToys = getCurrentToysFromTable();
                const newToys = data && Array.isArray(data.toys) ? data.toys : [];
                
                if (newToys.length > 0) {
                  // Check for new toys
                  newToys.forEach(toy => {
                    const existingToy = currentToys.find(t => t.toyId === toy.toyId);
                    if (!existingToy) {

                    }
                  });
                }
                
                renderToys(data);
                
                // Update multiple patterns toy dropdowns
                updateToyDropdowns();
              });

              lovensePattern.on('PatternSyncError', (data) => {
                console.log('PatternSyncError', data.msg);
                
                // Update the error log display
                const errorTimestamp = formatLocalDateTime();
                const errorLogEl = document.getElementById('pattern-sync-errors');
                
                // Clear "no errors" message if it exists
                if (errorLogEl.textContent.includes('No pattern sync errors detected yet')) {
                  errorLogEl.textContent = '';
                }
                
                // Add new error with timestamp
                const errorText = `${errorTimestamp}\n${data.msg}`;
                if (errorLogEl.textContent) {
                  errorLogEl.textContent = errorText + '\n\n' + errorLogEl.textContent;
                } else {
                  errorLogEl.textContent = errorText;
                }
              });
            } catch (err) {
              console.error(err);
              console.log('💥 SDK Error: Initialization error', { 
                error: String((err && err.stack) || err),
                stack: err && err.stack
              });
              setStatus('Initialization error, please check console');
            }
          }

          btnGenerateCtoken.addEventListener('click', generateCtoken);
          btnCreateObject.addEventListener('click', createLovensePatternObject);
          btnInit.addEventListener('click', initLovensePatternWhenReady);

          function renderConnections(data) {
            // Hide placeholder
            document.getElementById('connection-placeholder').style.display = 'none';
            
            // Display QR Code
            if (data.qrCode) {
              const qrEl = document.getElementById('connectionQr');
              const qrImg = document.getElementById('qrImage');
              qrImg.src = data.qrCode;
              qrEl.style.display = 'block';
            }

            // Display App Link
            if (data.appOpenUrl) {
              const linkEl = document.getElementById('connectionLink');
              const openLink = document.getElementById('openLink');
              openLink.href = data.appOpenUrl;
              openLink.textContent = 'Open Lovense Remote';
              linkEl.style.display = 'block';
            }

            // Display Unique Code
            if (data.code) {
              const codeEl = document.getElementById('connectionCode');
              const textCode = document.getElementById('textCode');
              textCode.textContent = data.code;
              codeEl.style.display = 'block';
            }
          }

          btnGetApp.addEventListener('click', function () {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('getapp-response').textContent = `${errorTimestamp}
❌ Error: Please complete initialization first.`;
              setStatus('Please complete initialization first');
              return;
            }
            
            lovensePattern.getApp((data) => {
              console.log('🔺 Connection data received:', data);
              
              // Show only the raw response data with forced line breaks
              const responseTimestamp = formatLocalDateTime();
              const formattedData = JSON.stringify(data, null, 2); // Add indentation for readability
              document.getElementById('getapp-response').textContent = `${responseTimestamp}
${formattedData}`;
              
              // Render connections (QR code, app link, unique code)
              renderConnections(data);
            });
          });

          audioEl.addEventListener('loadedmetadata', function () {
            if (!inputDuration.value && Number.isFinite(audioEl.duration)) {
              const durationSeconds = audioEl.duration;
              const durationMs = durationSeconds * 1000;
              inputDuration.value = String(durationSeconds.toFixed(3));

            }
          });

          btnLoadPattern.addEventListener('click', loadPatternFromUI);
          btnGetPatternList.addEventListener('click', getPatternList);
          btnExit.addEventListener('click', exitLovensePattern);

          // Multiple Patterns for Multiple Toys functionality
          let patternCounter = 0;

          // Add event listeners for multiple patterns functionality
          btnAddPattern.addEventListener('click', createPatternEntry);
          btnClearPatterns.addEventListener('click', clearAllPatterns);
          btnLoadMultiplePatterns.addEventListener('click', loadMultiplePatternsFromUI);



          function createPatternEntry() {
            patternCounter++;
            const patternId = `pattern-${patternCounter}`;
            
            const patternEntry = document.createElement('div');
            patternEntry.className = 'pattern-entry';
            
            patternEntry.innerHTML = `
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h4>Toy Pattern #${patternCounter}</h4>
                <div class="flex-row-8">
                  <button class="quick-pattern-btn" data-pattern-id="${patternId}" data-duration="20">20s</button>
                  <button class="quick-pattern-btn" data-pattern-id="${patternId}" data-duration="60">1m</button>
                  <button class="quick-pattern-btn" data-pattern-id="${patternId}" data-duration="300">5m</button>
                  <button class="quick-pattern-btn" data-pattern-id="${patternId}" data-duration="900">15m</button>
                  <button onclick="removePatternEntry('${patternId}')" style="border: 1px solid #dc3545; background: #f8f9fa; color: #dc3545; padding: 4px 8px; font-size: 11px; border-radius: 4px;">Remove</button>
                </div>
              </div>
              
              <!-- Toy and Type with labels inline -->
              <div style="display: flex; gap: 20px; margin-bottom: 12px; align-items: center;">
                <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                  <label class="small-label" style="min-width: 30px; margin-bottom: 0;">Toy:</label>
                  <select id="${patternId}-toyId" style="flex: 1;">
                    <option value="">Select connected toy...</option>
                  </select>
                </div>
                
                <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                  <label class="small-label" style="min-width: 35px; margin-bottom: 0;">Type:</label>
                  <select id="${patternId}-type" style="flex: 1;">
                    <option value="funScript">FunScript</option>
                    <option value="lovense">Lovense</option>
                  </select>
                </div>
              </div>
              
              <!-- Pattern Link and Data in same row with 30/70 ratio -->
              <div style="display: flex; gap: 20px; align-items: flex-start; margin-top: 12px;">
                <div style="flex: 0 0 calc(30% - 10px); min-width: 180px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary); font-size: 14px;">Pattern Link (optional):</label>
                  <input id="${patternId}-link" type="text" placeholder="https://example.com/pattern.funscript" style="width: 100%; padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;" />
                </div>
                <div style="flex: 0 0 calc(70% - 10px); min-width: 280px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary); font-size: 14px;">Pattern Data (FunScript JSON):</label>
                  <textarea id="${patternId}-data" placeholder='[{"at":1000, "pos":20}, {"at":3000, "pos":35}]' style="width: 100%; height: 80px; padding: 12px; border: 2px solid var(--border-color); border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; line-height: 1.4; box-sizing: border-box; resize: vertical;"></textarea>
                </div>
              </div>
              <div class="note" style="margin-top: 8px;">Note: If data is provided, it takes priority over pattern link.</div>
            `;
            
            patternEntry.id = patternId;
            multiplePatternsContainer.appendChild(patternEntry);
            
            // Populate toy dropdown with connected toys and select first one
            updateToyDropdowns();
            
            // Auto-select first connected toy for new patterns
            const toyDropdown = document.getElementById(`${patternId}-toyId`);
            const connectedToys = getConnectedToys();
            if (toyDropdown && connectedToys.length > 0) {
              toyDropdown.value = connectedToys[0].toyId;
            }
            
            return patternId;
          }

          function removePatternEntry(patternId) {
            const entry = document.getElementById(patternId);
            if (entry) {
              entry.remove();
            }
          }

          function updateToyDropdowns() {
            const toyDropdowns = document.querySelectorAll('[id$="-toyId"]');
            const connectedToys = getConnectedToys();
            
            toyDropdowns.forEach(dropdown => {
              const currentValue = dropdown.value;
              dropdown.innerHTML = '<option value="">Select a connected toy...</option>';
              
              connectedToys.forEach(toy => {
                const option = document.createElement('option');
                option.value = toy.toyId;
                // Display format: Full ToyName - Full ToyID
                const displayName = toy.nickName && toy.nickName !== 'Unknown' ? toy.nickName : toy.toyType;
                option.textContent = `${displayName} - ${toy.toyId}`;
                if (toy.toyId === currentValue) {
                  option.selected = true;
                }
                dropdown.appendChild(option);
              });
            });
          }

          function getConnectedToys() {
            // Get toys from the toys table
            const toyRows = toysTbodyEl.querySelectorAll('tr');
            const connectedToys = [];
            
            toyRows.forEach(row => {
              const cells = row.querySelectorAll('td');
              if (cells.length >= 6) {
                const connectionStatus = cells[4].textContent;
                if (connectionStatus === 'Connected') {
                  connectedToys.push({
                    toyId: cells[5].querySelector('code').textContent,
                    nickName: cells[0].textContent,
                    toyType: cells[1].textContent
                  });
                }
              }
            });
            
            return connectedToys;
          }

          function getCurrentToysFromTable() {
            // Get all toys from the toys table (both connected and disconnected)
            const toyRows = toysTbodyEl.querySelectorAll('tr');
            const allToys = [];
            
            toyRows.forEach(row => {
              const cells = row.querySelectorAll('td');
              if (cells.length >= 6) {
                allToys.push({
                  toyId: cells[5].querySelector('code').textContent,
                  nickName: cells[0].textContent,
                  toyType: cells[1].textContent,
                  connectionStatus: cells[4].textContent
                });
              }
            });
            
            return allToys;
          }

          function loadMultiplePatternsFromUI() {
            if (!lovensePattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: Please complete initialization first`;
              setStatus('Please complete initialization first');
              return;
            }

            const patternEntries = document.querySelectorAll('.pattern-entry');
            if (patternEntries.length === 0) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: No pattern entries found`;
              setStatus('Please add at least one toy pattern');
              return;
            }

            const patterns = [];
            let hasValidPattern = false;

            patternEntries.forEach(entry => {
              const toyId = entry.querySelector('[id$="-toyId"]').value.trim();
              const type = entry.querySelector('[id$="-type"]').value;
              const link = entry.querySelector('[id$="-link"]').value.trim();
              const dataText = entry.querySelector('[id$="-data"]').value.trim();

                              if (!toyId) {
                  const errorTimestamp = formatLocalDateTime();
                  document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: Toy ID is required for all patterns`;
                  return;
                }

              let data = null;
              if (dataText) {
                try {
                  data = JSON.parse(dataText);
                  if (!Array.isArray(data)) {
                    throw new Error('Data must be an array');
                  }
                                  } catch (e) {
                    const errorTimestamp = formatLocalDateTime();
                    document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: Invalid JSON data for toy ${toyId}: ${String(e)}`;
                    return;
                  }
              }

              const pattern = {
                type: type,
                toyId: toyId
              };

              if (data) {
                pattern.data = data;
              } else if (link) {
                pattern.patternLink = link;
                              } else {
                  const errorTimestamp = formatLocalDateTime();
                  document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: Pattern data or link is required for toy ${toyId}`;
                  return;
                }

              patterns.push(pattern);
              hasValidPattern = true;
            });

            if (!hasValidPattern) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}\n❌ Error: No valid patterns found`;
              setStatus('No valid patterns found');
              return;
            }

            setStatus('Loading multiple patterns...');
            const multipleTimestamp = formatLocalDateTime();
            
            // Show the actual call with truncated data for display
            const displayPatterns = patterns.map(pattern => {
              const displayPattern = { ...pattern };
              if (pattern.data) {
                const dataStr = JSON.stringify(pattern.data);
                if (dataStr.length > 200) {
                  const truncatedData = JSON.stringify(pattern.data.slice(0, 2)) + '...(truncated)';
                  displayPattern.data = `[${pattern.data.length} points] ${truncatedData}`;
                }
              }
              return displayPattern;
            });
            
            document.getElementById('multiple-patterns-call').textContent = `${multipleTimestamp}
lovensePattern.loadMultiplePatterns(${JSON.stringify(displayPatterns, null, 2)}).then((response) => {
  console.log('Multiple patterns loaded:', response);
}).catch((error) => {
  console.error('Loading failed:', error);
});`;
            
            // Enhanced logging for multiple patterns
            console.log('🔺 SDK Call: lovensePattern.loadMultiplePatterns()', { 
              method: 'loadMultiplePatterns',
              patternCount: patterns.length,
              toysInvolved: patterns.map(p => ({
                toyId: p.toyId,
                type: p.type,
                hasData: !!p.data,
                hasLink: !!p.patternLink,
                dataPoints: p.data ? p.data.length : 0
              }))
            });
            


            try {
              const responseTimestamp = formatLocalDateTime();
              const result = lovensePattern.loadMultiplePatterns(patterns);
              
              // Enhanced response display
              const responseInfo = {
                success: true,
                timestamp: responseTimestamp,
                patternsSubmitted: patterns.length,
                patterns: patterns.map((p, index) => ({
                  index: index + 1,
                  toyId: p.toyId,
                  type: p.type,
                  hasData: !!p.data,
                  hasLink: !!p.patternLink,
                  dataPoints: p.data ? p.data.length : 0
                })),
                sdkResponse: result
              };
              
              document.getElementById('multiple-patterns-response').textContent = `${responseTimestamp}
${JSON.stringify(result, null, 2)}`;
              
              console.log('✅ SDK Response: loadMultiplePatterns() successful', { 
                response: result,
                patternsLoaded: patterns.length,
                timestamp: responseTimestamp,
                detailedInfo: responseInfo
              });
              setStatus(`Multiple patterns loaded successfully (${patterns.length} patterns)`);
            } catch (err) {
              const errorTimestamp = formatLocalDateTime();
              document.getElementById('multiple-patterns-response').textContent = `${errorTimestamp}
Error: ${String((err && err.message) || err)}`;
              
              console.log('💥 SDK Error: loadMultiplePatterns() call error', { 
                error: String((err && err.message) || err),
                requestPayload: patterns,
                patternCount: patterns.length,
                stack: err && err.stack,
                timestamp: errorTimestamp
              });
              setStatus('Multiple patterns loading error');
            }
          }

          function clearAllPatterns() {
            multiplePatternsContainer.innerHTML = '';
            patternCounter = 0;
  
          }

          // Make removePatternEntry globally accessible for onclick handlers
          window.removePatternEntry = removePatternEntry;

          // Quick pattern examples for single pattern
          function generateQuickPattern(durationSeconds, variation = 0) {
            // Generate patterns with gentle intensity (soft mode)
            let basePattern;
            
            if (durationSeconds <= 20) {
              // 20 seconds pattern: 3-4 points, very gentle
              basePattern = [
                { "at": 5000, "pos": 15 },
                { "at": 12000, "pos": 25 },
                { "at": 20000, "pos": 20 }
              ];
            } else if (durationSeconds <= 60) {
              // 1 minute pattern: 4-5 points, gentle
              basePattern = [
                { "at": 10000, "pos": 15 },
                { "at": 30000, "pos": 25 },
                { "at": 45000, "pos": 20 },
                { "at": 60000, "pos": 30 }
              ];
            } else if (durationSeconds <= 300) {
              // 5 minutes pattern: 8-10 points, gentle
              basePattern = [
                { "at": 30000, "pos": 15 },
                { "at": 60000, "pos": 25 },
                { "at": 90000, "pos": 20 },
                { "at": 120000, "pos": 30 },
                { "at": 150000, "pos": 25 },
                { "at": 180000, "pos": 35 },
                { "at": 210000, "pos": 30 },
                { "at": 240000, "pos": 40 },
                { "at": 270000, "pos": 35 },
                { "at": 300000, "pos": 45 }
              ];
            } else if (durationSeconds <= 900) {
              // 15 minutes pattern: 15-20 points, gentle
              basePattern = [
                { "at": 60000, "pos": 15 },
                { "at": 120000, "pos": 25 },
                { "at": 180000, "pos": 20 },
                { "at": 240000, "pos": 30 },
                { "at": 300000, "pos": 25 },
                { "at": 360000, "pos": 35 },
                { "at": 420000, "pos": 30 },
                { "at": 480000, "pos": 40 },
                { "at": 540000, "pos": 35 },
                { "at": 600000, "pos": 45 },
                { "at": 660000, "pos": 25 },
                { "at": 720000, "pos": 35 },
                { "at": 780000, "pos": 30 },
                { "at": 840000, "pos": 40 },
                { "at": 900000, "pos": 35 }
              ];
            } else {
              // 30 minutes pattern: 25-30 points, gentle
              basePattern = [
                { "at": 120000, "pos": 15 },
                { "at": 240000, "pos": 25 },
                { "at": 360000, "pos": 20 },
                { "at": 480000, "pos": 30 },
                { "at": 600000, "pos": 25 },
                { "at": 720000, "pos": 35 },
                { "at": 840000, "pos": 30 },
                { "at": 960000, "pos": 40 },
                { "at": 1080000, "pos": 35 },
                { "at": 1200000, "pos": 45 },
                { "at": 1320000, "pos": 25 },
                { "at": 1440000, "pos": 35 },
                { "at": 1560000, "pos": 30 },
                { "at": 1680000, "pos": 40 },
                { "at": 1800000, "pos": 35 },
                { "at": 1920000, "pos": 45 },
                { "at": 2040000, "pos": 25 },
                { "at": 2160000, "pos": 35 },
                { "at": 2280000, "pos": 30 },
                { "at": 2400000, "pos": 40 },
                { "at": 2520000, "pos": 35 },
                { "at": 2640000, "pos": 45 },
                { "at": 2760000, "pos": 25 },
                { "at": 2880000, "pos": 35 },
                { "at": 3000000, "pos": 30 }
              ];
            }
            
            // Apply variation for multiple toys
            if (variation > 0) {
              basePattern = basePattern.map(point => ({
                ...point,
                pos: Math.max(5, Math.min(95, point.pos + (variation * 10) - 10))
              }));
            }
            
            // Scale pattern to fit duration
            const maxAt = Math.max(...basePattern.map(p => p.at));
            const targetDuration = durationSeconds * 1000;
            const scaleFactor = targetDuration / maxAt;
            
            return basePattern
              .map(p => ({
                at: Math.floor(p.at * scaleFactor),
                pos: p.pos
              }))
              .filter(p => p.at <= targetDuration);
          }

          function loadQuickPattern(durationSeconds) {
            const patterns = generateQuickPattern(durationSeconds);
            // Use compact format, no line breaks
            inputPatternData.value = JSON.stringify(patterns);
            

          }



          // Use event delegation for quick pattern buttons (including dynamically added ones)
          document.addEventListener('click', (e) => {
            if (e.target.classList.contains('quick-pattern-btn')) {
              const duration = parseInt(e.target.dataset.duration);
              const patternId = e.target.dataset.patternId;
              
              if (patternId) {
                // Individual pattern entry quick button
                const patterns = generateQuickPattern(duration, 0);
                const dataTextarea = document.getElementById(`${patternId}-data`);
                if (dataTextarea) {
                  // Use compact format, no line breaks
                  dataTextarea.value = JSON.stringify(patterns);
                }
              } else {
                // Single pattern section quick button
                loadQuickPattern(duration);
              }
            }
            

          });

          renderToys([]);
          
          // Create default pattern entry on page load
          setTimeout(() => {
            if (multiplePatternsContainer.children.length === 0) {
              createPatternEntry();
            }
          }, 500);
        })();
      </script>
    </div>
  </div>
</div>

