<div class="api-documentation">
    <h1>Lovense Toy Events Monitor</h1>
     <!-- API Reference -->
    <div class="api-reference">
        <p>This implementation is based on the <a href="https://developer.lovense.com/docs/standard-solutions/toy-events-api.html" target="_blank">Official Lovense Toy Events API</a>.</p>
    </div>

    <div class="control-panel">
        <div class="connection-details">
            <div class="input-group-row">
                <div class="input-group">
                    <label for="httpUrl">GameMode IP:</label>
                    <input type="text" id="httpUrl" placeholder="192.168.31.66">
                </div>
                <div class="input-group">
                    <label for="port">GameMode Port:</label>
                    <input type="text" id="port" placeholder="20010">
                </div>
                <div class="input-group">
                    <label for="appName">App Name:</label>
                    <input type="text" id="appName" placeholder="deltatest">
                </div>
            </div>
            <div class="button-group">
                <button id="connectBtn" class="btn primary">Connect</button>
                <button id="disconnectBtn" class="btn danger" disabled>Disconnect</button>
            </div>
        </div>

        <div class="main-content">
            <div class="monitoring-panel">
                <div class="connection-status-container">
                    <h2>Connection Status</h2>
                    <div id="connectionStatus" class="connection-status-box"></div>
                </div>

                <div class="event-log-container">
                    <div class="panel-header">
                        <h2>Event Log</h2>
                        <button id="clearLogBtn" class="btn secondary">Clear Log</button>
                    </div>
                    <div id="eventLog" class="log-area"></div>
                </div>
            </div>

            <div class="supported-toys">
                <h2>Supported Toys & Events</h2>
                <div class="table-container">
                    <table class="toy-events-table">
                        <thead>
                            <tr>
                                <th>Toy</th>
                                <th>Button</th>
                                <th>Function Strength Changed</th>
                                <th>Shake</th>
                                <th>Shake Frequency Changed</th>
                                <th>Battery Changed</th>
                                <th>Depth Changed</th>
                                <th>Motion Changed</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Nora</td>
                                <td>✅ index:0,1</td>
                                <td>✅ function: vibration,rotation</td>
                                <td>✅</td>
                                <td>✅</td>
                                <td>✅</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>Max 2</td>
                                <td>✅ index:0,1</td>
                                <td>✅ function: vibration,inflation</td>
                                <td>✅</td>
                                <td>✅</td>
                                <td>✅</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>Solace</td>
                                <td>✅ index:0,1,2,3</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td>✅</td>
                                <td>✅</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>Solace Pro</td>
                                <td>✅ index:0,1,2,3</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td>✅</td>
                                <td></td>
                                <td>✅</td>
                            </tr>
                            <tr>
                                <td>Mission2</td>
                                <td>✅ index:0,1</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td>✅</td>
                                <td></td>
                                <td>✅</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.api-documentation {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* API Reference styling */
.api-reference {
    background: #f8f9fa;
    border-left: 4px solid #3498db;
    padding: 1rem;
    margin-bottom: 2rem;
    border-radius: 0 4px 4px 0;
}

.api-reference p {
    margin: 0;
    font-size: 0.95rem;
    color: #2c3e50;
}

.api-reference a {
    color: #3498db;
    text-decoration: none;
    font-weight: 500;
}

.api-reference a:hover {
    text-decoration: underline;
}

h1, h2 {
    color: #2c3e50;
    margin-bottom: 1rem;
}

.control-panel {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    padding: 2rem;
    margin-bottom: 2rem;
}

.connection-details {
    margin-bottom: 2rem;
}

.input-group-row {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}

.input-group {
    flex: 1;
}

.input-group label {
    display: block;
    margin-bottom: 0.5rem;
    color: #666;
}

.input-group input {
    width: 100%;
    padding: 0.8rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.button-group {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
}

.btn {
    padding: 0.8rem 1.5rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

.btn.primary {
    background: #3498db;
    color: white;
}

.btn.primary:hover {
    background: #2980b9;
}

.btn.danger {
    background: #e74c3c;
    color: white;
}

.btn.danger:hover {
    background: #c0392b;
}

.main-content {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    margin-top: 2rem;
}

.monitoring-panel {
    width: 100%;
}

.connection-status-container {
    margin-bottom: 2rem;
}

.connection-status-box {
    position: relative;
    transform: none;
    height: 100px;
    overflow-y: auto;
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1rem;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.6;
}

.connection-status-box .log-entry {
    display: block;
    margin-bottom: 4px;
}

.connection-status-box .timestamp {
    color: #666;
}

.connection-status-box .event-type {
    color: #2980b9;
    font-weight: 500;
}

.connection-status-box .event-data {
    color: #27ae60;
}

.event-log-container {
    height: 600px;
    display: flex;
    flex-direction: column;
}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.panel-header h2 {
    margin: 0;
}

.log-area {
    flex: 1;
    min-height: 0;
    width: 100%;
    padding: 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.6;
    overflow-y: auto;
    background: #fff;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.log-entry {
    display: block;
    margin-bottom: 8px;
}

.log-entry .timestamp {
    color: #666;
}

.log-entry .event-type {
    color: #2980b9;
    font-weight: 500;
}

.log-entry .event-data {
    color: #27ae60;
    display: inline-block;
}

.log-entry .event-data pre {
    margin: 4px 0 0 20px;
    white-space: pre;
}

.table-container {
    overflow-x: auto;
    margin-top: 1rem;
    background: #fff;
    border-radius: 4px;
    border: 1px solid #ddd;
}

.toy-events-table {
    width: 100%;
    min-width: 800px;
    border-collapse: collapse;
}

.toy-events-table th,
.toy-events-table td {
    border: 1px solid #ddd;
    padding: 0.8rem;
    text-align: left;
}

.toy-events-table th {
    background: #f8f9fa;
    font-weight: 600;
}

.toy-events-table tr:nth-child(even) {
    background: #f8f9fa;
}

/* Remove the animation styles that were causing the box to fly */
.connection-status-box {
    transition: none;
    animation: none;
}

.btn.secondary {
    background: #95a5a6;
    color: white;
}

.btn.secondary:hover {
    background: #7f8c8d;
}

/* Remove unused styles */
.left-panel,
.right-panel {
    display: none;
}

.log-entry.error .event-type,
.log-entry.error .event-data {
    color: #c0392b;
    font-weight: 500;
}

.log-entry.error .event-data pre {
    color: #e74c3c;
}
</style>

<script>
class LovenseClient {
    constructor() {
        this.ws = null;
        this.isConnected = false;
        this.pingInterval = null;
        this.eventLog = document.getElementById('eventLog');
        this.connectionStatus = document.getElementById('connectionStatus');
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.reconnectTimeout = null;
    }

    constructWsUrl(ip, port) {
        // Use wss:// for ports starting with 3001* (HTTPS)
        // Use ws:// for ports starting with 2001* (HTTP)
        const isSecurePort = /^3001\d$/.test(port);
        const protocol = isSecurePort ? 'wss://' : 'ws://';
        return `${protocol}${ip}:${port}/v1`;
    }

    connect(serverUrl) {
        try {
            // Clear any existing connection attempts first
            this.disconnect();

            // Validate IP and port before attempting connection
            const urlParts = serverUrl.match(/^(wss?):\/\/([\d.]+):(\d+)\/v1/);
            if (!urlParts) {
                throw new Error('Invalid WebSocket URL format');
            }

            const [, protocol, ip, port] = urlParts;
            if (!ip || !port) {
                throw new Error('Invalid IP or port');
            }

            // Validate protocol matches port
            const isSecurePort = /^3001\d$/.test(port);
            const isSecureProtocol = protocol === 'wss';
            if (isSecurePort !== isSecureProtocol) {
                throw new Error('Protocol and port mismatch');
            }

            this.updateConnectionStatus(`Connecting to ${serverUrl}...`);
            
            this.ws = new WebSocket(serverUrl);
            
            const connectTimeout = setTimeout(() => {
                if (this.ws && this.ws.readyState !== WebSocket.OPEN) {
                    const error = 'Connection timeout. Possible causes:\n' +
                        '1. Lovense Connect app is not running\n' +
                        '2. Game Mode is not enabled in Lovense Connect\n' +
                        '3. IP/Port are incorrect\n' +
                        '4. Firewall is blocking the connection';
                    this.logEvent('Error', error);
                    this.ws.close();
                    this.tryReconnect();
                }
            }, 10000);

            this.ws.addEventListener('open', () => {
                clearTimeout(connectTimeout);
                this.reconnectAttempts = 0;
                this.isConnected = true;
                this.updateConnectionUIStatus();
                this.logEvent('Connection', 'WebSocket connected successfully');
                this.requestAccess();
            });

            this.setupEventListeners();
        } catch (error) {
            this.logDetailedError('Connection failed', error);
        }
    }

    setupEventListeners() {
        this.ws.addEventListener('message', (event) => {
            try {
                const message = JSON.parse(event.data);
                if (!message.type.includes('pong')) {
                    this.logEvent('Received', message);
                }
                this.handleMessage(message);
            } catch (error) {
                this.logDetailedError('Message parsing failed', error);
            }
        });

        this.ws.addEventListener('close', (event) => {
            this.isConnected = false;
            this.updateConnectionUIStatus();
            this.stopPing();
            
            const reason = this.getCloseReason(event.code);
            this.logEvent('Connection', `WebSocket closed (${event.code}): ${reason}`);
            
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                this.tryReconnect();
            }
        });

        this.ws.addEventListener('error', (error) => {
            this.logDetailedError('WebSocket error', error);
        });
    }

    handleMessage(message) {
        const { type } = message;
        
        switch (type) {
            case 'access-granted':
                this.accessGranted = true;
                this.logEvent('Access', 'Access granted to Lovense device');
                this.startPing();
                break;

            case 'toy-list':
                if (message.toyList && Array.isArray(message.toyList)) {
                    message.toyList.forEach(toy => {
                        this.updateConnectionStatus(`Connected: ${toy.type} (${toy.id})`);
                    });
                }
                break;

            case 'toy-status':
                this.updateConnectionStatus(`Status changed: ${message.toyId} - ${message.data.connected ? 'Connected' : 'Disconnected'}`);
                break;

            case 'button-down':
                this.handleButtonPress(message.toyId, message.index, true);
                this.updateConnectionStatus(`Button down: ${message.toyId} - Button ${message.index}`);
                break;

            case 'button-up':
                this.handleButtonPress(message.toyId, message.index, false);
                this.updateConnectionStatus(`Button up: ${message.toyId} - Button ${message.index}`);
                break;

            case 'button-pressed':
                this.animateSpaceship(message.toyId, 'pulse-effect');
                this.updateConnectionStatus(`Button pressed: ${message.toyId} - Button ${message.index}`);
                break;

            case 'depth-changed':
                this.handleDepthChange(message.toyId, message.value);
                this.updateConnectionStatus(`Depth changed: ${message.toyId} - Value: ${message.value}`);
                break;

            case 'function-strength-changed':
                this.handleStrengthChange(message.toyId, message.data);
                this.updateConnectionStatus(`Strength changed: ${message.toyId} - ${message.data.function}: ${message.data.value}`);
                break;

            case 'battery-changed':
                this.updateBattery(message.toyId, message.data.value);
                this.updateConnectionStatus(`Battery changed: ${message.toyId} - ${message.data.value}%`);
                break;

            case 'motion-changed':
                this.handleMotion(message.toyId, message.data.motionData);
                this.updateConnectionStatus(`Motion changed: ${message.toyId} - ${message.data.motionData.length} data points`);
                break;
        }
    }

    requestAccess() {
        const appName = document.getElementById('appName').value.trim() || 'deltatest';
        const accessRequest = {
            type: 'access',
            data: {
                appName: appName
            }
        };
        this.sendMessage(accessRequest);
    }

    animateSpaceship(toyId, effectClass) {
        const connectionStatus = this.connectionStatus;
        if (!connectionStatus) return;

        connectionStatus.classList.add(effectClass);
        setTimeout(() => {
            connectionStatus.classList.remove(effectClass);
        }, 300);
    }

    handleStrengthChange(toyId, data) {
        // Remove animation, just log the change
        this.updateConnectionStatus(`Strength changed: ${toyId} - ${data.function}: ${data.value}`);
    }

    updateBattery(toyId, value) {
        const connectionStatus = this.connectionStatus;
        if (!connectionStatus) return;

        // Update battery level
        const batteryLevel = connectionStatus.querySelector('.battery-level');
        if (batteryLevel) {
            batteryLevel.style.width = `${value}%`;
        }
    }

    handleMotion(toyId, motionData) {
        const connectionStatus = this.connectionStatus;
        if (!connectionStatus) return;

        // Just log the motion data instead of animating
        this.updateConnectionStatus(`Motion changed: ${toyId} - ${motionData.length} data points`);
    }

    startPing() {
        this.stopPing();
        this.pingInterval = setInterval(() => {
            this.sendMessage({ type: 'ping' });
        }, 5000);
    }

    stopPing() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
    }

    sendMessage(message) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
            if (message.type !== 'ping') {
                this.logEvent('Sent', message);
            }
        }
    }

    disconnect() {
        // Clear any pending reconnection attempts
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
            this.reconnectAttempts = 0;
        }

        // Stop ping interval
        this.stopPing();

        // Close WebSocket if it exists
        if (this.ws) {
            this.ws.close(1000, "User initiated disconnect");
            this.ws = null;
        }

        // Update status
        this.isConnected = false;
        this.updateConnectionUIStatus();
        this.logEvent('Connection', 'Disconnected from server');
    }

    getChineseTimestamp() {
        const options = {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        };
        return new Date().toLocaleString('zh-CN', options);
    }

    logEvent(type, data) {
        const timestamp = this.getChineseTimestamp();
        
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        // Add error class for error-related events
        if (type.toLowerCase().includes('error') || 
            (typeof data === 'string' && data.toLowerCase().includes('error'))) {
            logEntry.classList.add('error');
        }
        
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = `[${timestamp}] `;
        
        const eventTypeSpan = document.createElement('span');
        eventTypeSpan.className = 'event-type';
        eventTypeSpan.textContent = type;
        
        const eventDataSpan = document.createElement('span');
        eventDataSpan.className = 'event-data';
        
        if (typeof data === 'object') {
            eventDataSpan.textContent = ': ';
            const pre = document.createElement('pre');
            pre.textContent = JSON.stringify(data, null, 2);
            eventDataSpan.appendChild(pre);
        } else {
            eventDataSpan.textContent = `: ${data}`;
        }
        
        logEntry.appendChild(timestampSpan);
        logEntry.appendChild(eventTypeSpan);
        logEntry.appendChild(eventDataSpan);
        
        this.eventLog.appendChild(logEntry);
        this.eventLog.scrollTop = this.eventLog.scrollHeight;
    }

    updateConnectionUIStatus() {
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        
        connectBtn.disabled = this.isConnected;
        disconnectBtn.disabled = !this.isConnected;
        connectBtn.textContent = this.isConnected ? 'Connected' : 'Connect';
    }

    updateConnectionStatus(message) {
        const timestamp = new Date().toLocaleTimeString();
        const [eventType, ...eventData] = message.split(':');
        
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = `[${timestamp}] `;
        
        const eventTypeSpan = document.createElement('span');
        eventTypeSpan.className = 'event-type';
        eventTypeSpan.textContent = eventType;
        
        const eventDataSpan = document.createElement('span');
        eventDataSpan.className = 'event-data';
        eventDataSpan.textContent = eventData.length ? `: ${eventData.join(':')}` : '';
        
        logEntry.appendChild(timestampSpan);
        logEntry.appendChild(eventTypeSpan);
        logEntry.appendChild(eventDataSpan);
        
        this.connectionStatus.appendChild(logEntry);
        this.connectionStatus.scrollTop = this.connectionStatus.scrollHeight;
    }

    tryReconnect() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
        }

        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);
        
        this.logEvent('Connection', `Reconnect attempt ${this.reconnectAttempts} of ${this.maxReconnectAttempts} in ${delay/1000} seconds...`);
        
        this.reconnectTimeout = setTimeout(() => {
            const ip = document.getElementById('httpUrl').value.trim() || '192.168.31.66';
            const port = document.getElementById('port').value.trim() || '20010';
            
            // Validate IP and port
            if (!ip.match(/^\d{1,3}(\.\d{1,3}){3}$/)) {
                this.logEvent('Error', 'Invalid IP address format');
                return;
            }
            
            if (!port.match(/^(2001\d|3001\d)$/)) {
                this.logEvent('Error', 'Invalid port number. Must be 2001* for HTTP or 3001* for HTTPS');
                return;
            }
            
            const serverUrl = this.constructWsUrl(ip, port);
            this.connect(serverUrl);
        }, delay);
    }

    getCloseReason(code) {
        const closeReasons = {
            1000: 'Normal closure',
            1001: 'Going away',
            1002: 'Protocol error',
            1003: 'Unsupported data',
            1004: 'Reserved',
            1005: 'No status received',
            1006: 'Abnormal closure',
            1007: 'Invalid frame payload data',
            1008: 'Policy violation',
            1009: 'Message too big',
            1010: 'Mandatory extension',
            1011: 'Internal server error',
            1015: 'TLS handshake'
        };
        return closeReasons[code] || 'Unknown reason';
    }

    logDetailedError(context, error) {
        const errorDetails = {
            context,
            message: error.message || 'No error message',
            timestamp: this.getChineseTimestamp(),
            readyState: this.ws ? this.ws.readyState : 'No WebSocket',
            browserInfo: navigator.userAgent
        };

        // Use error class for detailed errors
        this.logEvent('Detailed Error', errorDetails);
        console.error('Detailed WebSocket Error:', errorDetails);
        
        this.isConnected = false;
        this.updateConnectionUIStatus();
    }

    handleButtonPress(toyId, buttonIndex, isDown) {
        const connectionStatus = this.connectionStatus;
        if (!connectionStatus) return;

        const buttonIndicator = connectionStatus.querySelector(`.button-${buttonIndex}`);
        if (buttonIndicator) {
            buttonIndicator.classList.toggle('button-active', isDown);
        }
    }

    handleDepthChange(toyId, value) {
        // Remove animation, just log the change
        this.updateConnectionStatus(`Depth changed: ${toyId} - Value: ${value}`);
    }

    clearLogs() {
        while (this.eventLog.firstChild) {
            this.eventLog.removeChild(this.eventLog.firstChild);
        }
        while (this.connectionStatus.firstChild) {
            this.connectionStatus.removeChild(this.connectionStatus.firstChild);
        }
    }
}

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    const client = new LovenseClient();
    
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const clearLogBtn = document.getElementById('clearLogBtn');
    const ipInput = document.getElementById('httpUrl');
    const portInput = document.getElementById('port');
    
    // Update clear log button handler
    clearLogBtn.addEventListener('click', () => {
        client.clearLogs();
    });
    
    connectBtn.addEventListener('click', () => {
        const ip = ipInput.value.trim() || '192.168.31.66';
        const port = portInput.value.trim() || '20010';
        
        try {
            const serverUrl = client.constructWsUrl(ip, port);
            client.connect(serverUrl);
        } catch (error) {
            alert(`Invalid connection parameters: ${error.message}`);
        }
    });

    disconnectBtn.addEventListener('click', () => {
        client.disconnect();
    });
});
</script>